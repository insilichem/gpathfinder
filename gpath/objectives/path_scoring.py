#!/usr/bin/env python
# -*- coding: utf-8 -*-

##############
# GPathFinder: Identification of ligand pathways by a multi-objective
# genetic algorithm
# 
# https://github.com/insilichem/gpathfinder
#
# Copyright 2019 José-Emilio Sánchez Aparicio, Giuseppe Sciortino,
# Daniel Villadrich Herrmannsdoerfer, Pablo Orenes Chueca, 
# Jaime Rodríguez-Guerra Pedregal and Jean-Didier Maréchal
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#      http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
##############

"""
This objective provides an evaluation of the quality of the pathways 
generated by the a GPathFinder ``path`` gene.
There are the following methods of evaluation:
    1. Clashes, understood as steric conflicts that increases the energy
       of the system. They are evaluated as the sum of volumetric 
       overlapping of the Van der Waals' spheres of the implied atoms.
       Typically, the goal will be to minimize the clashes score 
       (weight=-1).
    2. Vina score, a wrapper around the scoring functions provided by
       `Autodock Vina <http://vina.scripps.edu/>`_. Typically, the goal
       will be to minimize the vina score (weight=-1).
    3. Smoothness, RMSD between 2 consecutive conformations of the ligand
       (considering its rotation and torsions). Used if we want to obtain
       trajectories of the ligand without abruptous switching of the 
       ligand between one frame and the next one. Typically, the goal 
       will be to minimize the smoothness score (weight=-1).
The selected method will be applied over all the frames of the pathway. 
A global score for the pathway will be returned to GPathFinder for its 
evaluation stage, and individual scores of each frame will be stored in
the ``path`` gene for further export in the output files.
"""

# Python
from __future__ import print_function
import logging
import os
from tempfile import _get_default_tempdir as default_tempdir
from tempfile import _get_candidate_names as tempnames
import subprocess
import copy
import gc
from math import sqrt

# 3rd party
import simtk.openmm.app as openmm_app

# Chimera
from WriteMol2 import writeMol2
import chimera
import DetectClash
from chimera import Xform as X
import Matrix as M

# GPATH
from gpath import parse
from gpath.objectives import ObjectiveProvider, path_vina, path_smina

logger = logging.getLogger(__name__)
_openmm_builtin_forcefields = os.listdir(os.path.join(openmm_app.__path__[0], 'data'))


def enable(**kwargs):
    kwargs = PathScoring.validate(kwargs)
    return PathScoring(**kwargs)

class PathScoring(ObjectiveProvider):
    """
    PathScoring class

    Parameters
    ----------
    probe : str
        Name of the GPathFinder ``pathway`` gene that is object of analysis.
    ligand : str, optional, defaults to 'Ligand'
        Name of the GPathFinder ``molecule`` gene representing the ligand.
    protein : str, optional, defaults to 'Protein'
        Name of the GPathFinder ``molecule`` gene representing the protein.
    radius : float, optional, defaults to 5.0
        Maximum distance from any point of the ligand in every frame 
        that is searched for possible interactions.
    which : {'clashes', 'vina', 'smina', 'smoothness'}, 
            optional, defaults to 'clashes'
        Type of interactions to measure.
    method : {'sum', 'average', 'max'}, optional, defaults to 'sum'
        Method used to calculate the score (i.e. sum, average or maximum
        of the scores of all frames).
    clash_threshold : float, optional, defaults to 0.6
        Used when method is ``clashes``. Maximum overlap of  van-der-Waals 
        spheres.If the overlap is greater, it's considered a clash.
    bond_separation : int, optional, defaults to 4
        Used when ``which`` is ``clashes``. Ignore clashes between atoms 
        within n bonds.
    same_residue : bool, optional, defaults to True
        Used when ``which`` is ``clashes``. Include intra-residue 
        clashes. 
    smoothness_threshold : float, optional, defaults to 0.0
        Used when ``which`` is ``smoothness``. RMSD between ligands on two
        consecutive frames that is permitted considering a perfect score
        of smoothness. 
    smina_scoring : str, optional
        Used when ``which`` is ``smina`` to specify alternative builtin 
        scoring function (e.g. vinardo). Defaults to None
    smina_custom_scoring : str, optional
        Used when ``which`` is ``smina`` to specify a custom scoring function
        file. Defaults to None
    smina_custom_atoms : str, optional
        Used when ``which`` is ``smina`` to specify a custom atom type
        parameters file. Defaults to None

    Returns
    -------
    float
        Sum/avg/max for all the frames of the pathway of:
        - Volumetric overlap of VdW spheres in A³ if ``which``=
        ``clashes``.
        - Vina score if ``which``=``vina``.
        - Smina score if ``which``=``smina``.
        - RMSD if ``which``=``smoothness``.
    """
    _validate = {
        parse.Required('probe'): parse.Molecule_name,
        'ligand': parse.Molecule_name,
        'protein': parse.Molecule_name,
        'radius': parse.All(parse.Coerce(float), parse.Range(min=0)),
        'which': parse.In(['clashes', 'vina', 'smina', 'smoothness']),
        'method': parse.In(['sum', 'average', 'max']),
        'clash_threshold': parse.Coerce(float),
        'bond_separation': parse.All(parse.Coerce(int), parse.Range(min=2)),
        'same_residue': parse.Coerce(bool),
        'smoothness_threshold': float,
        'smina_scoring': str,
        'smina_custom_scoring': parse.RelPathToInputFile(),
        'smina_custom_atoms': parse.RelPathToInputFile(),
        }

    def __init__(self, probe, ligand='Ligand', protein='Protein', radius=5.0, 
                 which='clashes', method='average', clash_threshold=0.6, 
                 bond_separation=4, same_residue=True,
                 smoothness_threshold=0.0, smina_scoring=None,
                 smina_custom_scoring=None, smina_custom_atoms=None,
                 *args, **kwargs):
        ObjectiveProvider.__init__(self, **kwargs)
        self._probe = probe
        self._ligand = ligand
        self._protein = protein
        self.which = which
        self.method = method
        self.radius = radius
        self.clash_threshold = clash_threshold
        self.bond_separation = bond_separation
        self.same_residue = same_residue
        self.smina_scoring = smina_scoring
        self.smina_custom_scoring = smina_custom_scoring
        self.smina_custom_atoms = smina_custom_atoms

        if which == 'clashes':
            self.evaluate = self.evaluate_clashes
            self.threshold = clash_threshold
        elif which == 'vina':
            self.vina_scorer = path_vina.Vina(self._protein, self._ligand, 
                                prepare_each=False)
            self.evaluate = self.evaluate_vina
        elif which == 'smina':
            self.smina_scorer = path_smina.Smina(self._protein, self._ligand,
                                scoring=self.smina_scoring,
                                custom_scoring=self.smina_custom_scoring,
                                custom_atoms=self.smina_custom_atoms)
            self.evaluate = self.evaluate_smina
        elif which == 'smoothness':
            self.evaluate = self.evaluate_smoothness
            self.threshold = smoothness_threshold

    def get_molecule_by_name(self, ind, name):
        """
        Get a molecule gene instance of individual by its name
        """
        return ind.find_molecule(name)

    def molecules(self, ind):
        """
        Get all the chimera molecules from the individual
        """
        return [m.compound.mol for m in ind._molecules.values()]

    def ligand(self, ind):
        """
        Get the chimera ligand molecule
        """
        return ind.find_molecule(ind.genes[self._probe].ligand).compound.mol

    def protein(self, ind):
        """
        Get the chimera protein molecule
        """
        return ind.find_molecule(ind.genes[self._probe].protein).compound.mol

    def evaluate_clashes(self, ind):
        """
        Calculate clashes for all the frames that have changed (not 'clashes'
        key present in scores). It sums the clashes of every frame to return a 
        global score for all the pathway.
        """
        scores = ind.genes[self._probe].scores
        clashscore = 0.0
        for i in range(0, len(ind.genes[self._probe].allele['positions'])):
            if not 'clashes' in scores[i].keys():
                ind.genes[self._probe].gp_express(i)
                #Calculate interactions
                negative = self.find_interactions(ind, i)
                clash_point = sum(abs(vol_overlap) for (a1, a2, overlap, vol_overlap) in negative)
                scores[i]['clashes'] = clash_point
                if self.method == 'sum' or self.method == 'average':
                    clashscore += clash_point
                ind.genes[self._probe].gp_unexpress(i)
            else:
                if self.method == 'sum' or self.method == 'average':
                    clashscore += scores[i]['clashes']
        if self.method == 'sum':
            return clashscore
        elif self.method == 'average':
            return clashscore / len(ind.genes[self._probe].allele['positions'])
        elif self.method == 'max':
            sc = [score['clashes'] for score in scores[1:]]
            return max(sc)

    def evaluate_vina(self, ind):
        """
        Calculate vina score for all the frames that have changed (not 'vina' 
        key present in scores). It sums the vina scores of every frame to 
        return a global score for all the pathway.
        """
        scores = ind.genes[self._probe].scores

        vinascore = 0.0
        for i in range(0, len(ind.genes[self._probe].allele['positions'])):
            if not 'vina' in scores[i].keys():
                ind.genes[self._probe].gp_express(i)

                vina_point = self.vina_scorer.evaluate(ind)
                scores[i]['vina'] = vina_point
                if self.method == 'sum' or self.method == 'average':
                    vinascore += vina_point
            
                ind.genes[self._probe].gp_unexpress(i)
            else:
                if self.method == 'sum' or self.method == 'average':
                    vinascore += scores[i]['vina']
        if self.method == 'sum':
            return vinascore
        elif self.method == 'average':
            return vinascore / len(ind.genes[self._probe].allele['positions'])
        elif self.method == 'max':
            sc = [score['vina'] for score in scores[1:]]
            return max(sc)

    def evaluate_smina(self, ind):
        """
        Calculate smina score for all the frames that have changed (not 'smina' 
        key present in scores). It sums the smina scores of every frame to 
        return a global score for all the pathway.
        """
        scores = ind.genes[self._probe].scores

        sminascore = 0.0
        for i in range(0, len(ind.genes[self._probe].allele['positions'])):
            if not 'smina' in scores[i].keys():
                ind.genes[self._probe].gp_express(i)

                smina_point = self.smina_scorer.evaluate(ind)
                scores[i]['smina'] = smina_point
                if self.method == 'sum' or self.method == 'average':
                    sminascore += smina_point
            
                ind.genes[self._probe].gp_unexpress(i)
            else:
                if self.method == 'sum' or self.method == 'average':
                    sminascore += scores[i]['smina']
        if self.method == 'sum':
            return sminascore
        elif self.method == 'average':
            return sminascore / len(ind.genes[self._probe].allele['positions'])
        elif self.method == 'max':
            sc = [score['smina'] for score in scores[1:]]
            return max(sc)

    def evaluate_smoothness(self, ind):
        """
        Calculate RMSD difference of the ligands between frames. If the 
        resulting score is under a stablished threshold, returns 0.
        """
        scores = ind.genes[self._probe].scores

        smoothscore = 0.0
        
        #Frame 0
        ind.genes[self._probe].gp_express(0, with_rotamers=False, smoothness=True)
        prev_ligand_atoms_coords = self._get_mol_coords(self.ligand(ind))
        ind.genes[self._probe].gp_unexpress(0, smoothness=True)
        scores[0]['smoothness'] = 0
        
        for i in range(1, len(ind.genes[self._probe].allele['positions'])):

            if not 'smoothness' in scores[i].keys():
                ind.genes[self._probe].gp_express(i, with_rotamers=False, smoothness=True)
 
                #Calculate smoothness
                current_ligand_atoms_coords = self._get_mol_coords(self.ligand(ind))
                smooth_point = self._distance_atom_sets(prev_ligand_atoms_coords, current_ligand_atoms_coords)
                if smooth_point < self.threshold:
                    smooth_point = 0.0
                #Prepare next position of the pathway
                prev_ligand_atoms_coords = self._get_mol_coords(self.ligand(ind))

                scores[i]['smoothness'] = smooth_point
                if self.method == 'sum' or self.method == 'average':
                    smoothscore += smooth_point
                ind.genes[self._probe].gp_unexpress(i, smoothness=True)

            else:

                if self.method == 'sum' or self.method == 'average':
                    smoothscore += scores[i]['smoothness']
                #Prepare next position of the pathway if necessary
                if i < (len(ind.genes[self._probe].allele['positions']) - 1):
                    if not 'smoothness' in scores[i+1].keys():
                        ind.genes[self._probe].gp_express(i, with_rotamers=False, smoothness=True)
                        prev_ligand_atoms_coords = self._get_mol_coords(self.ligand(ind))
                        ind.genes[self._probe].gp_unexpress(i, smoothness=True)

        if self.method == 'sum':
            return smoothscore
        elif self.method == 'average':
            return smoothscore / len(ind.genes[self._probe].allele['positions'])
        elif self.method == 'max':
            sc = [score['smoothness'] for score in scores[1:]]
            return max(sc)

    def find_interactions(self, ind, i, only_ligand=False):
        atoms = self._surrounding_atoms(ind, i, only_ligand=only_ligand)
        options = dict(test=atoms, intraRes=self.same_residue, 
                       interSubmodel=True, clashThreshold=self.threshold, 
                       assumedMaxVdw=2.1, hbondAllowance=0.2, 
                       bondSeparation=self.bond_separation)
        clashes = DetectClash.detectClash(atoms, **options)
        return self._analyze_interactions(clashes)

    def _analyze_interactions(self, clashes):
        """
        Interpret contacts provided by DetectClash.
        Parameters
        ----------
        clashes : dict of dict
            Output of DetectClash. It's a dict of atoms, whose values 
            are dicts. These subdictionaries contain all the contacting 
            atoms as keys, and the respective overlaping length as 
            values.
        Returns
        -------
        negative : list of list
            Each sublist depict an interaction, with four items: the two 
            involved atoms, their distance, and their volumetric overlap.
        .. note ::
            Repulsive interactions are measured with the volumetric 
            overlap of the involved atoms' Van der Waals spheres.
        """
        negative = []
        for a1, clash in clashes.items():
            for a2, overlap in clash.items():
                if overlap > self.clash_threshold:
                # overlap > clash threshold : clash!
                    volumetric_overlap = self._vdw_vol_overlap(a1, a2, overlap)
                    negative.append([a1, a2, overlap, volumetric_overlap])
        return negative

    def _surrounding_atoms(self, ind, i, only_ligand=False):
        """
        Get atoms in the search zone, based on the ligand/rotamers and the 
        radius.
        """
        self.zone.clear()
        self.zone.add([a for a in self.ligand(ind).atoms])
        if not only_ligand:
            #Add beta carbons of rotamers to find clashes in its surroundings
            if ind.genes[self._probe].rotamers_gene :
                prot_residues = []
                for res in ind.genes[self._probe].allele['rotamers'][i][0]:
                    p, r = res.split('/')
                    prot_residues.extend([x for x in self.protein(ind).residues if str(x.id.position) == r])
                beta_carbons = []
                for r in prot_residues:
                    beta_carbons.extend([a for a in r.atoms if a.name == 'CB'])
                self.zone.add(beta_carbons)

            self.zone.merge(chimera.selection.REPLACE,
                            chimera.specifier.zone(self.zone, 'atom', None,
                                                   self.radius, 
                                                   self.molecules(ind)))
        return self.zone.atoms()

    @staticmethod
    def _vdw_vol_overlap(a1, a2, overlap=None):
        """
        Volumetric overlap of Van der Waals spheres of atoms.
        Parameters
        ----------
        a1, a2 : chimera.Atom
        overlap : float
            Overlapping sphere segment of involved atoms
        .. note ::
            Adapted from Eran Eyal, Comput Chem 25: 712-724, 2004
        """
        PI = 3.14159265359
        if overlap is None:
            d = a1.xformCoord().distance(a2.xformCoord())
        else:
            d = a1.radius + a2.radius - overlap
        if d == 0:
            return 1000
        h_a, h_b = 0, 0
        if d < (a1.radius + a2.radius):
            h_a = (a2.radius ** 2 - (d - a1.radius) ** 2) / (2 * d)
            h_b = (a1.radius ** 2 - (d - a2.radius) ** 2) / (2 * d)

        return (PI / 3) * ((h_a ** 2) * (3 * a1.radius - h_a) +
                (h_b ** 2) * (3 * a2.radius - h_b))

    @staticmethod
    def _distance_atom_sets(set1, set2):
        distance = 0.0
        for atom_serial in set2.keys():
            ax, ay, az = set1[atom_serial]
            bx, by, bz = set2[atom_serial]
            distance += sqrt((bx-ax)*(bx-ax)+(by-ay)*(by-ay)+(bz-az)*(bz-az))
        return distance / len(set2.keys())

    @staticmethod
    def _get_mol_coords(chimera_mol):
        coords = {}
        for atom in chimera_mol.atoms:
            coords[atom.serialNumber] = list(atom.xformCoord())
        return coords
